{
  "version": 3,
  "sources": ["../../three/examples/jsm/math/OBB.js"],
  "sourcesContent": ["import {\n\tBox3,\n\tMathUtils,\n\tMatrix4,\n\tMatrix3,\n\tRay,\n\tVector3\n} from 'three';\n\n// module scope helper variables\n\nconst a = {\n\tc: null, // center\n\tu: [ new Vector3(), new Vector3(), new Vector3() ], // basis vectors\n\te: [] // half width\n};\n\nconst b = {\n\tc: null, // center\n\tu: [ new Vector3(), new Vector3(), new Vector3() ], // basis vectors\n\te: [] // half width\n};\n\nconst R = [[], [], []];\nconst AbsR = [[], [], []];\nconst t = [];\n\nconst xAxis = new Vector3();\nconst yAxis = new Vector3();\nconst zAxis = new Vector3();\nconst v1 = new Vector3();\nconst size = new Vector3();\nconst closestPoint = new Vector3();\nconst rotationMatrix = new Matrix3();\nconst aabb = new Box3();\nconst matrix = new Matrix4();\nconst inverse = new Matrix4();\nconst localRay = new Ray();\n\n/**\n * Represents an oriented bounding box (OBB) in 3D space.\n *\n * @three_import import { OBB } from 'three/addons/math/OBB.js';\n */\nclass OBB {\n\n\t/**\n\t * Constructs a new OBB.\n\t *\n\t * @param {Vector3} [center] - The center of the OBB.\n\t * @param {Vector3} [halfSize] - Positive halfwidth extents of the OBB along each axis.\n\t * @param {Matrix3} [rotation] - The rotation of the OBB.\n\t */\n\tconstructor( center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3() ) {\n\n\t\t/**\n\t\t * The center of the OBB.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.center = center;\n\n\t\t/**\n\t\t * Positive halfwidth extents of the OBB along each axis.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.halfSize = halfSize;\n\n\t\t/**\n\t\t * The rotation of the OBB.\n\t\t *\n\t\t * @type {Matrix3}\n\t\t */\n\t\tthis.rotation = rotation;\n\n\t}\n\n\t/**\n\t * Sets the OBBs components to the given values.\n\t *\n\t * @param {Vector3} [center] - The center of the OBB.\n\t * @param {Vector3} [halfSize] - Positive halfwidth extents of the OBB along each axis.\n\t * @param {Matrix3} [rotation] - The rotation of the OBB.\n\t * @return {OBB} A reference to this OBB.\n\t */\n\tset( center, halfSize, rotation ) {\n\n\t\tthis.center = center;\n\t\tthis.halfSize = halfSize;\n\t\tthis.rotation = rotation;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the values of the given OBB to this instance.\n\t *\n\t * @param {OBB} obb - The OBB to copy.\n\t * @return {OBB} A reference to this OBB.\n\t */\n\tcopy( obb ) {\n\n\t\tthis.center.copy( obb.center );\n\t\tthis.halfSize.copy( obb.halfSize );\n\t\tthis.rotation.copy( obb.rotation );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new OBB with copied values from this instance.\n\t *\n\t * @return {OBB} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Returns the size of this OBB.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The size.\n\t */\n\tgetSize( target ) {\n\n\t\treturn target.copy( this.halfSize ).multiplyScalar( 2 );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this OBB.\n\t *\n\t * @param {Vector3} point - The point that should be clamped within the bounds of this OBB.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @returns {Vector3} - The clamped point.\n\t */\n\tclampPoint( point, target ) {\n\n\t\t// Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n\t\t// by Christer Ericson (chapter 5.1.4)\n\n\t\tconst halfSize = this.halfSize;\n\n\t\tv1.subVectors( point, this.center );\n\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// start at the center position of the OBB\n\n\t\ttarget.copy( this.center );\n\n\t\t// project the target onto the OBB axes and walk towards that point\n\n\t\tconst x = MathUtils.clamp( v1.dot( xAxis ), - halfSize.x, halfSize.x );\n\t\ttarget.add( xAxis.multiplyScalar( x ) );\n\n\t\tconst y = MathUtils.clamp( v1.dot( yAxis ), - halfSize.y, halfSize.y );\n\t\ttarget.add( yAxis.multiplyScalar( y ) );\n\n\t\tconst z = MathUtils.clamp( v1.dot( zAxis ), - halfSize.z, halfSize.z );\n\t\ttarget.add( zAxis.multiplyScalar( z ) );\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point lies within this OBB.\n\t *\n\t * @param {Vector3} point - The point to test.\n\t * @returns {boolean} - Whether the given point lies within this OBB or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\tv1.subVectors( point, this.center );\n\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// project v1 onto each axis and check if these points lie inside the OBB\n\n\t\treturn Math.abs( v1.dot( xAxis ) ) <= this.halfSize.x &&\n\t\t\t\tMath.abs( v1.dot( yAxis ) ) <= this.halfSize.y &&\n\t\t\t\tMath.abs( v1.dot( zAxis ) ) <= this.halfSize.z;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given AABB intersects this OBB.\n\t *\n\t * @param {Box3} box3 - The AABB to test.\n\t * @returns {boolean} - Whether the given AABB intersects this OBB or not.\n\t */\n\tintersectsBox3( box3 ) {\n\n\t\treturn this.intersectsOBB( obb.fromBox3( box3 ) );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding sphere intersects this OBB.\n\t *\n\t * @param {Sphere} sphere - The bounding sphere to test.\n\t * @returns {boolean} - Whether the given bounding sphere intersects this OBB or not.\n\t */\n\tintersectsSphere( sphere ) {\n\n\t\t// find the point on the OBB closest to the sphere center\n\n\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t// if that point is inside the sphere, the OBB and sphere intersect\n\n\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given OBB intersects this OBB.\n\t *\n\t * @param {OBB} obb - The OBB to test.\n\t * @param {number} [epsilon=Number.EPSILON] - A small value to prevent arithmetic errors.\n\t * @returns {boolean} - Whether the given OBB intersects this OBB or not.\n\t */\n\tintersectsOBB( obb, epsilon = Number.EPSILON ) {\n\n\t\t// Reference: OBB-OBB Intersection in Real-Time Collision Detection\n\t\t// by Christer Ericson (chapter 4.4.1)\n\n\t\t// prepare data structures (the code uses the same nomenclature like the reference)\n\n\t\ta.c = this.center;\n\t\ta.e[ 0 ] = this.halfSize.x;\n\t\ta.e[ 1 ] = this.halfSize.y;\n\t\ta.e[ 2 ] = this.halfSize.z;\n\t\tthis.rotation.extractBasis( a.u[ 0 ], a.u[ 1 ], a.u[ 2 ] );\n\n\t\tb.c = obb.center;\n\t\tb.e[ 0 ] = obb.halfSize.x;\n\t\tb.e[ 1 ] = obb.halfSize.y;\n\t\tb.e[ 2 ] = obb.halfSize.z;\n\t\tobb.rotation.extractBasis( b.u[ 0 ], b.u[ 1 ], b.u[ 2 ] );\n\n\t\t// compute rotation matrix expressing b in a's coordinate frame\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tR[ i ][ j ] = a.u[ i ].dot( b.u[ j ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute translation vector\n\n\t\tv1.subVectors( b.c, a.c );\n\n\t\t// bring translation into a's coordinate frame\n\n\t\tt[ 0 ] = v1.dot( a.u[ 0 ] );\n\t\tt[ 1 ] = v1.dot( a.u[ 1 ] );\n\t\tt[ 2 ] = v1.dot( a.u[ 2 ] );\n\n\t\t// compute common subexpressions. Add in an epsilon term to\n\t\t// counteract arithmetic errors when two edges are parallel and\n\t\t// their cross product is (near) null\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tAbsR[ i ][ j ] = Math.abs( R[ i ][ j ] ) + epsilon;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet ra, rb;\n\n\t\t// test axes L = A0, L = A1, L = A2\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tra = a.e[ i ];\n\t\t\trb = b.e[ 0 ] * AbsR[ i ][ 0 ] + b.e[ 1 ] * AbsR[ i ][ 1 ] + b.e[ 2 ] * AbsR[ i ][ 2 ];\n\t\t\tif ( Math.abs( t[ i ] ) > ra + rb ) return false;\n\n\n\t\t}\n\n\t\t// test axes L = B0, L = B1, L = B2\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tra = a.e[ 0 ] * AbsR[ 0 ][ i ] + a.e[ 1 ] * AbsR[ 1 ][ i ] + a.e[ 2 ] * AbsR[ 2 ][ i ];\n\t\t\trb = b.e[ i ];\n\t\t\tif ( Math.abs( t[ 0 ] * R[ 0 ][ i ] + t[ 1 ] * R[ 1 ][ i ] + t[ 2 ] * R[ 2 ][ i ] ) > ra + rb ) return false;\n\n\t\t}\n\n\t\t// test axis L = A0 x B0\n\n\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 1 ][ 0 ];\n\t\trb = b.e[ 1 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 1 ];\n\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 0 ] - t[ 1 ] * R[ 2 ][ 0 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A0 x B1\n\n\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 1 ][ 1 ];\n\t\trb = b.e[ 0 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 0 ];\n\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 1 ] - t[ 1 ] * R[ 2 ][ 1 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A0 x B2\n\n\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 1 ][ 2 ];\n\t\trb = b.e[ 0 ] * AbsR[ 0 ][ 1 ] + b.e[ 1 ] * AbsR[ 0 ][ 0 ];\n\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 2 ] - t[ 1 ] * R[ 2 ][ 2 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A1 x B0\n\n\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 0 ][ 0 ];\n\t\trb = b.e[ 1 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 1 ];\n\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 0 ] - t[ 2 ] * R[ 0 ][ 0 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A1 x B1\n\n\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 0 ][ 1 ];\n\t\trb = b.e[ 0 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 0 ];\n\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 1 ] - t[ 2 ] * R[ 0 ][ 1 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A1 x B2\n\n\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 0 ][ 2 ];\n\t\trb = b.e[ 0 ] * AbsR[ 1 ][ 1 ] + b.e[ 1 ] * AbsR[ 1 ][ 0 ];\n\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 2 ] - t[ 2 ] * R[ 0 ][ 2 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A2 x B0\n\n\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 0 ] + a.e[ 1 ] * AbsR[ 0 ][ 0 ];\n\t\trb = b.e[ 1 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 1 ];\n\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 0 ] - t[ 0 ] * R[ 1 ][ 0 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A2 x B1\n\n\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 1 ] + a.e[ 1 ] * AbsR[ 0 ][ 1 ];\n\t\trb = b.e[ 0 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 0 ];\n\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 1 ] - t[ 0 ] * R[ 1 ][ 1 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A2 x B2\n\n\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 2 ] + a.e[ 1 ] * AbsR[ 0 ][ 2 ];\n\t\trb = b.e[ 0 ] * AbsR[ 2 ][ 1 ] + b.e[ 1 ] * AbsR[ 2 ][ 0 ];\n\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 2 ] - t[ 0 ] * R[ 1 ][ 2 ] ) > ra + rb ) return false;\n\n\t\t// since no separating axis is found, the OBBs must be intersecting\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given plane intersects this OBB.\n\t *\n\t * @param {Plane} plane - The plane to test.\n\t * @returns {boolean} Whether the given plane intersects this OBB or not.\n\t */\n\tintersectsPlane( plane ) {\n\n\t\t// Reference: Testing Box Against Plane in Real-Time Collision Detection\n\t\t// by Christer Ericson (chapter 5.2.3)\n\n\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;\n\n\t\tconst r = this.halfSize.x * Math.abs( plane.normal.dot( xAxis ) ) +\n\t\t\t\tthis.halfSize.y * Math.abs( plane.normal.dot( yAxis ) ) +\n\t\t\t\tthis.halfSize.z * Math.abs( plane.normal.dot( zAxis ) );\n\n\t\t// compute distance of the OBB's center from the plane\n\n\t\tconst d = plane.normal.dot( this.center ) - plane.constant;\n\n\t\t// Intersection occurs when distance d falls within [-r,+r] interval\n\n\t\treturn Math.abs( d ) <= r;\n\n\t}\n\n\t/**\n\t * Performs a ray/OBB intersection test and stores the intersection point\n\t * in the given 3D vector.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The intersection point. If no intersection is detected, `null` is returned.\n\t */\n\tintersectRay( ray, target ) {\n\n\t\t// the idea is to perform the intersection test in the local space\n\t\t// of the OBB.\n\n\t\tthis.getSize( size );\n\t\taabb.setFromCenterAndSize( v1.set( 0, 0, 0 ), size );\n\n\t\t// create a 4x4 transformation matrix\n\n\t\tmatrix.setFromMatrix3( this.rotation );\n\t\tmatrix.setPosition( this.center );\n\n\t\t// transform ray to the local space of the OBB\n\n\t\tinverse.copy( matrix ).invert();\n\t\tlocalRay.copy( ray ).applyMatrix4( inverse );\n\n\t\t// perform ray <-> AABB intersection test\n\n\t\tif ( localRay.intersectBox( aabb, target ) ) {\n\n\t\t\t// transform the intersection point back to world space\n\n\t\t\treturn target.applyMatrix4( matrix );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given ray intersects this OBB.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @returns {boolean} Whether the given ray intersects this OBB or not.\n\t */\n\tintersectsRay( ray ) {\n\n\t\treturn this.intersectRay( ray, v1 ) !== null;\n\n\t}\n\n\t/**\n\t * Defines an OBB based on the given AABB.\n\t *\n\t * @param {Box3} box3 - The AABB to setup the OBB from.\n\t * @return {OBB} A reference of this OBB.\n\t */\n\tfromBox3( box3 ) {\n\n\t\tbox3.getCenter( this.center );\n\n\t\tbox3.getSize( this.halfSize ).multiplyScalar( 0.5 );\n\n\t\tthis.rotation.identity();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given OBB is equal to this OBB.\n\t *\n\t * @param {OBB} obb - The OBB to test.\n\t * @returns {boolean} Whether the given OBB is equal to this OBB or not.\n\t */\n\tequals( obb ) {\n\n\t\treturn obb.center.equals( this.center ) &&\n\t\t\tobb.halfSize.equals( this.halfSize ) &&\n\t\t\tobb.rotation.equals( this.rotation );\n\n\t}\n\n\t/**\n\t * Applies the given transformation matrix to this OBB. This method can be\n\t * used to transform the bounding volume with the world matrix of a 3D object\n\t * in order to keep both entities in sync.\n\t *\n\t * @param {Matrix4} matrix - The matrix to apply.\n\t * @return {OBB} A reference of this OBB.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\tconst e = matrix.elements;\n\n\t\tlet sx = v1.set( e[ 0 ], e[ 1 ], e[ 2 ] ).length();\n\t\tconst sy = v1.set( e[ 4 ], e[ 5 ], e[ 6 ] ).length();\n\t\tconst sz = v1.set( e[ 8 ], e[ 9 ], e[ 10 ] ).length();\n\n\t\tconst det = matrix.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\trotationMatrix.setFromMatrix4( matrix );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\trotationMatrix.elements[ 0 ] *= invSX;\n\t\trotationMatrix.elements[ 1 ] *= invSX;\n\t\trotationMatrix.elements[ 2 ] *= invSX;\n\n\t\trotationMatrix.elements[ 3 ] *= invSY;\n\t\trotationMatrix.elements[ 4 ] *= invSY;\n\t\trotationMatrix.elements[ 5 ] *= invSY;\n\n\t\trotationMatrix.elements[ 6 ] *= invSZ;\n\t\trotationMatrix.elements[ 7 ] *= invSZ;\n\t\trotationMatrix.elements[ 8 ] *= invSZ;\n\n\t\tthis.rotation.multiply( rotationMatrix );\n\n\t\tthis.halfSize.x *= sx;\n\t\tthis.halfSize.y *= sy;\n\t\tthis.halfSize.z *= sz;\n\n\t\tv1.setFromMatrixPosition( matrix );\n\t\tthis.center.add( v1 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst obb = new OBB();\n\nexport { OBB };\n"],
  "mappings": "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",
  "names": ["obb", "matrix"]
}
