<!DOCTYPE html>
<html lang="pl-PL">

<head>
	<title>Labirynt</title>
	<meta charset="UTF-8">
  <meta name="description" content="Zaliczenie zajęć - projekt labiryntu">
  <meta name="keywords" content="HTML, THREE.JS, JavaScript">
  <meta name="author" content="Maciej Płuciennik">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		body {
			margin: 0px;
		}
	</style>
	<script type="importmap">
	    {
	        "imports": { "three": "/jsm/three.module.js" }
	    }
	</script>
	<script type="module">

		/*
		Zwykły three.js nie posiada możliwości użycia OBB, jest ale jej konstruktor nie działa ?
		Używam więc modułu i bibliotek z katalogu jsm, nie js
		*/

		import * as THREE from '../jsm/three.module.js';
		import * as OBBJs from "../jsm/OBB.js";
		import * as OrbitControlsJs from "../jsm/OrbitControls.js";

		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
		camera.lookAt(scene.position);
		const camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
		const renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.physicallyCorrectLights = true;

		const shadowMap = renderer.shadowMap; // mapa cieni renderera

		shadowMap.enabled = true;
		shadowMap.type = THREE.PCFSoftShadowMap; // bardziej 'miękkie' cienie
		shadowMap.renderSingleSided = false; // renderuje przód i tył geometrii
		shadowMap.renderReverseSided = false; // blokuje traktowanie przodu geometrii jako jej tyłu i na odwrót 
		shadowMap.darkness = 0.9; // intensywność cieni, żeby przebić się przez ciemniejsze tekstury oraz ciemny ambient

		document.body.appendChild(renderer.domElement);

		const controls = new OrbitControlsJs.OrbitControls(camera2, renderer.domElement);
		
		// Grupy

		const rotate = new THREE.Group();

		// Zmienne pomocnicze

		let ctr1 = 0;
		let ctr2 = 0;
		let ctr3 = 0;
		let ctr4 = 0;
		let ctr5 = 0;
		let ctr6 = 0;
		let ctr7 = 0;
		let ctr8 = 0;
		let ctr9 = 0;
		let ctr10 = 0;
		let ctr11 = 0;
		let ctr12 = 0;
		let ctr13 = 0;
		let ctr14 = 0;
		let ctr15 = 0;
		let ctr16 = 0;
		let speedFactor = 0.6;
		let rotSpeed = 0.02;
		let fPressCtr = 0;
		let cPressCtr = 0;
		let metal = 0; // efekt 'lustra'
		let rough = 1;
		const skala171 = 1.429444166666667; // skala171
		const skala308 = 2.567221666666667; // skala308
		const skala444 = 3.705; // skala444
		const skala581 = 4.8427775; // skala581
		const skala717 = 5.980555833333333; // skala717
		const skala854 = 7.118334166666667; // skala854
		const skala990 = 8.256110833333333; // skala990
		const skala1946 = 16.220555; // skala1946
		const skala2083 = 17.35833333333333; // skala2083
		const skala4131 = 34.425; // skala4131
		const skalaS = 0.2916666666666667;
		let key = [];
		const positions = [
			[-1979.7333, 60.001, -1911.4667], //skala 171 poziom zielony
			[-614.4, 60.001, -1911.4667],
			[-68.2666, 60.001, -1911.4667],
			[887.4667, 60.001, -1911.4667],
			[-1843.2, 60.001, -1774.9333],
			[-1160.5334, 60.001, -1774.9333],
			[-477.8666, 60.001, -1774.9333],
			[477.8667, 60.001, -1774.9333],
			[614.4, 60.001, -1638.4],
			[-887.4666, 60.001, -1501.8667],
			[204.8, 60.001, -1501.8667],
			[1979.7333, 60.001, -1501.8667],
			[-1024, 60.001, -1365.3333],
			[-341.3333, 60.001, -1365.3333],
			[1297.0667, 60.001, -1365.3333],
			[1570.1333, 60.001, -1365.3333],
			[1843.2, 60.001, -1365.3333],
			[-1843.2, 60.001, -1228.8],
			[-1297.0667, 60.001, -1228.8],
			[-477.8666, 60.001, -1228.8],
			[1160.5333, 60.001, -1228.8],
			[-1979.7333, 60.001, -1092.2667],
			[-1706.6667, 60.001, -1092.2667],
			[-750.9333, 60.001, -1092.2667],
			[1706.6667, 60.001, -1092.2667],
			[-1979.7333, 60.001, -955.7333],
			[-1297.0667, 60.001, -955.7333],
			[-1024, 60.001, -955.7333],
			[-204.8, 60.001, -955.7333],
			[614.4, 60.001, -955.7333],
			[887.4667, 60.001, -955.7333],
			[-1570.1334, 60.001, -819.2],
			[-1160.5334, 60.001, -819.2],
			[-68.2666, 60.001, -819.2],
			[750.9333, 60.001, -819.2],
			[1024, 60.001, -819.2],
			[1570.1333, 60.001, -819.2],
			[1843.2, 60.001, -819.2],
			[-1433.6, 60.001, -682.6667],
			[-1024, 60.001, -682.6667],
			[-341.3333, 60.001, -682.6667],
			[204.8, 60.001, -682.6667],
			[-1706.6667, 60.001, -546.1333],
			[-1297.0667, 60.001, -546.1333],
			[-887.4666, 60.001, -546.1333],
			[-204.8, 60.001, -546.1333],
			[68.2667, 60.001, -546.1333],
			[341.3334, 60.001, -546.1333],
			[1024, 60.001, -409.6],
			[-1979.7333, 60.001, -273.0667],
			[-204.8, 60.001, -273.0667],
			[341.3334, 60.001, -273.0667],
			[614.4, 60.001, -273.0667],
			[1433.6, 60.001, -273.0667],
			[1706.6667, 60.001, -273.0667],
			[-1570.1334, 60.001, -136.5333],
			[-1297.0667, 60.001, -136.5333],
			[-204.8, 60.001, -136.5333],
			[68.2667, 60.001, -136.5333],
			[477.8667, 60.001, -136.5333],
			[750.9333, 60.001, -136.5333],
			[1297.0667, 60.001, -136.5333],
			[1843.2, 60.001, -136.5333],
			[-1160.5334, 60.001, 0],
			[750.9333, 60.001, 0],
			[1297.0667, 60.001, 0],
			[-1570.1334, 60.001, 136.5333],
			[-750.9333, 60.001, 136.5333],
			[68.2667, 60.001, 136.5333],
			[614.4, 60.001, 136.5333],
			[887.4667, 60.001, 136.5333],
			[1160.5333, 60.001, 136.5333],
			[-614.4, 60.001, 273.0667],
			[1433.6, 60.001, 273.0667],
			[204.8, 60.001, 409.6],
			[1843.2, 60.001, 409.6],
			[-1570.1334, 60.001, 546.1333],
			[1433.6, 60.001, 546.1333],
			[-1024, 60.001, 682.6667],
			[-477.8666, 60.001, 682.6667],
			[614.4, 60.001, 682.6667],
			[1433.6, 60.001, 682.6667],
			[-1979.7333, 60.001, 819.2],
			[-887.4666, 60.001, 819.2],
			[-341.3333, 60.001, 819.2],
			[1570.1333, 60.001, 819.2],
			[-1160.5334, 60.001, 955.7333],
			[-614.4, 60.001, 955.7333],
			[-341.3333, 60.001, 955.7333],
			[750.9333, 60.001, 955.7333],
			[1024, 60.001, 955.7333],
			[-1570.1334, 60.001, 1092.2667],
			[-1024, 60.001, 1092.2667],
			[-614.4, 60.001, 1092.2667],
			[68.2667, 60.001, 1092.2667],
			[341.3334, 60.001, 1092.2667],
			[614.4, 60.001, 1092.2667],
			[1160.5333, 60.001, 1092.2667],
			[1706.6667, 60.001, 1092.2667],
			[-1843.2, 60.001, 1228.8],
			[-887.4666, 60.001, 1228.8],
			[-68.2666, 60.001, 1228.8],
			[204.8, 60.001, 1228.8],
			[614.4, 60.001, 1228.8],
			[1843.2, 60.001, 1228.8],
			[-1706.6667, 60.001, 1365.3333],
			[1024, 60.001, 1365.3333],
			[1706.6667, 60.001, 1365.3333],
			[1979.7333, 60.001, 1365.3333],
			[-1843.2, 60.001, 1501.8667],
			[-750.9333, 60.001, 1501.8667],
			[477.8667, 60.001, 1501.8667],
			[750.9333, 60.001, 1501.8667],
			[-1843.2, 60.001, 1638.4],
			[-750.9333, 60.001, 1638.4],
			[-477.8666, 60.001, 1638.4],
			[-1979.7333, 60.001, 1774.9333],
			[341.3334, 60.001, 1774.9333],
			[614.4, 60.001, 1774.9333],
			[1570.1333, 60.001, 1774.9333],
			[1979.7333, 60.001, 1774.9333],
			[-1024, 60.001, 1911.4667],
			[1570.1333, 60.001, 1911.4667],
			[1843.2, 60.001, 1911.4667],
			[-1911.4667, 60.001, 1706.6667], // skala 171 pion różowy
			[-1911.4667, 60.001, -887.4667],
			[-1911.4667, 60.001, -1570.1333],
			[-1774.9334, 60.001, 1297.0667],
			[-1774.9334, 60.001, -68.2667],
			[-1774.9334, 60.001, -341.3333],
			[-1774.9334, 60.001, -1706.6667],
			[-1638.4, 60.001, 887.4667],
			[-1638.4, 60.001, 204.8],
			[-1638.4, 60.001, -68.2667],
			[-1638.4, 60.001, -750.9333],
			[-1501.8667, 60.001, 1843.2],
			[-1501.8667, 60.001, 1433.6],
			[-1501.8667, 60.001, 68.2667],
			[-1501.8667, 60.001, -341.3333],
			[-1501.8667, 60.001, -614.4],
			[-1501.8667, 60.001, -1433.6],
			[-1501.8667, 60.001, -1843.2],
			[-1365.3334, 60.001, 1433.6],
			[-1365.3334, 60.001, -1160.5333],
			[-1365.3334, 60.001, -1570.1333],
			[-1365.3334, 60.001, -1979.7333],
			[-1228.8, 60.001, 1843.2],
			[-1228.8, 60.001, 1570.1333],
			[-1228.8, 60.001, 1297.0667],
			[-1228.8, 60.001, 204.8],
			[-1228.8, 60.001, -204.8],
			[-1228.8, 60.001, -477.8667],
			[-1228.8, 60.001, -1843.2],
			[-1092.2667, 60.001, 477.8667],
			[-1092.2667, 60.001, 204.8],
			[-1092.2667, 60.001, -68.2667],
			[-1092.2667, 60.001, -341.3333],
			[-1092.2667, 60.001, -614.4],
			[-1092.2667, 60.001, -1160.5333],
			[-1092.2667, 60.001, -1433.6],
			[-1092.2667, 60.001, -1979.7333],
			[-955.7333, 60.001, 1979.7333],
			[-955.7333, 60.001, 1706.6667],
			[-955.7333, 60.001, -68.2667],
			[-955.7333, 60.001, -1843.2],
			[-819.2, 60.001, 1843.2],
			[-819.2, 60.001, 1570.1333],
			[-819.2, 60.001, 341.3333],
			[-819.2, 60.001, 68.2667],
			[-819.2, 60.001, -477.8667],
			[-819.2, 60.001, -750.9333],
			[-819.2, 60.001, -1024],
			[-819.2, 60.001, -1297.0667],
			[-682.6666, 60.001, 1706.6667],
			[-682.6666, 60.001, -68.2667],
			[-682.6666, 60.001, -1843.2],
			[-546.1333, 60.001, 887.4667],
			[-546.1333, 60.001, 477.8667],
			[-546.1333, 60.001, 204.8],
			[-546.1333, 60.001, -750.9333],
			[-546.1333, 60.001, -1297.0667],
			[-546.1333, 60.001, -1706.6667],
			[-546.1333, 60.001, -1979.7333],
			[-409.6, 60.001, 1706.6667],
			[-409.6, 60.001, -1297.0667],
			[-409.6, 60.001, -1570.1333],
			[-409.6, 60.001, -1843.2],
			[-273.0666, 60.001, -341.3333],
			[-136.5333, 60.001, 477.8667],
			[-136.5333, 60.001, 204.8],
			[-136.5333, 60.001, -750.9333],
			[-136.5333, 60.001, -1570.1333],
			[0, 60.001, 1979.7333],
			[0, 60.001, 1160.5333],
			[136.5334, 60.001, 1843.2],
			[136.5334, 60.001, 1297.0667],
			[136.5334, 60.001, 1024],
			[136.5334, 60.001, -1979.7333],
			[273.0667, 60.001, 1706.6667],
			[273.0667, 60.001, -614.4],
			[409.6, 60.001, 1025],
			[409.6, 60.001, 341.3333],
			[409.6, 60.001, -614.4],
			[546.1334, 60.001, 477.8667],
			[546.1334, 60.001, -1160.5333],
			[682.6667, 60.001, 1843.2],
			[682.6667, 60.001, 1160.5333],
			[682.6667, 60.001, 887.4667],
			[682.6667, 60.001, 614.4],
			[682.6667, 60.001, -204.8],
			[682.6667, 60.001, -477.8667],
			[819.2, 60.001, -1570.1333],
			[955.7333, 60.001, 1843.2],
			[1092.2667, 60.001, 1433.6],
			[1092.2667, 60.001, 614.4],
			[1092.2667, 60.001, -614.4],
			[1092.2667, 60.001, -1843.2],
			[1228.8, 60.001, 750.9333],
			[1228.8, 60.001, 68.2667],
			[1228.8, 60.001, -341.3333],
			[1228.8, 60.001, -1979.7333],
			[1501.8667, 60.001, 750.9333],
			[1501.8667, 60.001, 477.8667],
			[1501.8667, 60.001, -614.4],
			[1501.8667, 60.001, -1024],
			[1638.4, 60.001, 750.9333],
			[1638.4, 60.001, -1433.6],
			[1638.4, 60.001, -1843.2],
			[1774.9333, 60.001, 1706.6667],
			[1774.9333, 60.001, 1433.6],
			[1774.9333, 60.001, 1160.5333],
			[1774.9333, 60.001, -204.8],
			[1774.9333, 60.001, -1160.5333],
			[1774.9333, 60.001, -1433.6],
			[1774.9333, 60.001, -1843.2],
			[1911.4667, 60.001, 1843.2],
			[1911.4667, 60.001, 1570.1333],
			[1911.4667, 60.001, 614.4],
			[1911.4667, 60.001, 341.3333],
			[1911.4667, 60.001, -1024],
			[1911.4667, 60.001, -1297.0667],
			[1911.4667, 60.001, -1706.6667],
			[1911.4667, 60.001, -1911.4667], // skala 308 poziom ciemny niebieski pastelowy
			[-1501.8667, 60.001, -1774.9333],
			[0, 60.001, -1774.9333],
			[955.7333, 60.001, -1774.9333],
			[1774.9333, 60.001, -1774.9333],
			[-1774.9333, 60.001, -1638.4],
			[955.7333, 60.001, -1638.4],
			[-1774.9333, 60.001, -1501.8667],
			[-1228.8, 60.001, -1501.8667],
			[682.6667, 60.001, -1501.8667],
			[1092.2667, 60.001, -1501.8667],
			[-1365.3334, 60.001, -1365.3333],
			[-682.6666, 60.001, -1365.3333],
			[0, 60.001, -1365.3333],
			[546.1334, 60.001, -1365.3333],
			[955.7333, 60.001, -1365.3333],
			[-955.7333, 60.001, -1228.8],
			[-136.5333, 60.001, -1228.8],
			[-1638.4, 60.001, -955.7333],
			[-546.1333, 60.001, -955.7333],
			[409.6, 60.001, -819.2],
			[-1774.9333, 60.001, -682.6667],
			[1365.3333, 60.001, -546.1333],
			[-1774.9333, 60.001, -409.6],
			[-1228.8, 60.001, -409.6],
			[-273.06663, 60.001, -409.6],
			[682.6667, 60.001, -409.6],
			[1365.3333, 60.001, -409.6],
			[1774.9333, 60.001, -409.6],
			[-1638.4, 60.001, -273.0667],
			[-546.1333, 60.001, -273.0667],
			[-955.7333, 60.001, -136.5333],
			[-546.1333, 60.001, -136.5333],
			[-136.5333, 60.001, 0],
			[273.0667, 60.001, 0],
			[1774.9333, 60.001, 0],
			[-1092.2667, 60.001, 136.5333],
			[-1365.3334, 60.001, 273.0667],
			[-955.7333, 60.001, 273.0667],
			[-273.0666, 60.001, 273.0667],
			[409.6, 60.001, 273.0667],
			[-1228.8, 60.001, 409.6],
			[682.6667, 60.001, 409.6],
			[-1228.8, 60.001, 546.1333],
			[-819.2, 60.001, 546.1333],
			[409.6, 60.001, 546.1333],
			[1092.2667, 60.001, 546.1333],
			[-1365.3334, 60.001, 682.6667],
			[-136.5333, 60.001, 682.6667],
			[273.0667, 60.001, 682.6667],
			[955.7333, 60.001, 682.6667],
			[1774.9333, 60.001, 682.6667],
			[-1501.8667, 60.001, 819.2],
			[1092.2667, 60.001, 819.2],
			[1911.4667, 60.001, 819.2],
			[0, 60.001, 955.7333],
			[1501.8667, 60.001, 955.7333],
			[-273.0666, 60.001, 1092.2667],
			[-1365.3334, 60.001, 1228.8],
			[-409.6, 60.001, 1228.8],
			[955.7333, 60.001, 1228.8],
			[-1092.2667, 60.001, 1365.3333],
			[-409.6, 60.001, 1365.3333],
			[682.6667, 60.001, 1365.3333],
			[1638.4, 60.001, 1501.8667],
			[1092.2667, 60.001, 1638.4],
			[1228.8, 60.001, 1774.9333],
			[136.5334, 60.001, 1911.4667],
			[682.6667, 60.001, 1911.4667],
			[-1911.4667, 60.001, -136.5333], // skala 308 pion pomarańczowy
			[-1911.4667, 60.001, -546.1333],
			[-1774.9334, 60.001, 1774.9333],
			[-1774.9334, 60.001, 955.7333],
			[-1774.9334, 60.001, -682.6667],
			[-1774.9334, 60.001, -1092.2667],
			[-1638.4, 60.001, 1638.4],
			[-1638.4, 60.001, 1228.8],
			[-1638.4, 60.001, -1365.3333],
			[-1501.8667, 60.001, 546.1333],
			[-1365.3334, 60.001, 1092.2667],
			[-1228.8, 60.001, -819.2],
			[-1228.8, 60.001, -1365.3333],
			[-1092.2667, 60.001, 1365.3333],
			[-1092.2667, 60.001, 819.2],
			[-682.6666, 60.001, -1228.8],
			[-546.1333, 60.001, 1501.8667],
			[-409.6, 60.001, 682.6667],
			[-409.6, 60.001, 136.5333],
			[-136.5333, 60.001, 1365.3333],
			[-136.5333, 60.001, 819.2],
			[-136.5333, 60.001, -136.5333],
			[-136.5333, 60.001, -1228.8],
			[-136.5333, 60.001, -1911.4667],
			[0, 60.001, -409.6],
			[0, 60.001, -1501.8667],
			[136.5334, 60.001, -136.5333],
			[136.5334, 60.001, -1501.8667],
			[273.0667, 60.001, -273.0667],
			[409.6, 60.001, 1911.4667],
			[409.6, 60.001, 0],
			[409.6, 60.001, -1774.9333],
			[546.1334, 60.001, -136.5333],
			[682.6667, 60.001, 1501.8667],
			[682.6667, 60.001, 273.0667],
			[682.6667, 60.001, -819.2],
			[682.6667, 60.001, -1228.8],
			[682.6667, 60.001, -1911.4667],
			[819.2, 60.001, 1774.9333],
			[819.2, 60.001, 1228.8],
			[819.2, 60.001, 0],
			[819.2, 60.001, -955.7333],
			[819.2, 60.001, -1911.4667],
			[955.7333, 60.001, -1501.8667],
			[1092.2667, 60.001, 273.0667],
			[1092.2667, 60.001, -136.5333],
			[1228.8, 60.001, 409.6],
			[1228.8, 60.001, -1638.4],
			[1365.3333, 60.001, -1501.8667],
			[1365.3333, 60.001, -1911.4667],
			[1501.8667, 60.001, 1501.8667],
			[1501.8667, 60.001, 1092.2667],
			[1501.8667, 60.001, -1774.9333],
			[1638.4, 60.001, 1092.2667],
			[1638.4, 60.001, 409.6],
			[1911.4667, 60.001, 955.7333],
			[-1570.1334, 60.001, -1911.4667], // skala 444 poziom jasny niebieski
			[-1024, 60.001, -1911.4667],
			[-1297.0667, 60.001, -1638.4],
			[-750.9333, 60.001, -1638.4],
			[-204.8, 60.001, -1638.4],
			[1706.6667, 60.001, -1638.4],
			[-477.8666, 60.001, -1501.8667],
			[1570.1333, 60.001, -1501.8667],
			[-1843.2, 60.001, -1365.3333],
			[750.9333, 60.001, -1228.8],
			[1570.1333, 60.001, -1228.8],
			[-1297.0667, 60.001, -1092.2667],
			[-341.3333, 60.001, -1092.2667],
			[887.4667, 60.001, -1092.2667],
			[204.8, 60.001, -955.7333],
			[-750.9333, 60.001, -819.2],
			[614.4, 60.001, -682.6667],
			[1297.0667, 60.001, -682.6667],
			[-750.9333, 60.001, -409.6],
			[204.8, 60.001, -409.6],
			[1024, 60.001, -273.0667],
			[-1570.1334, 60.001, 0],
			[887.4667, 60.001, 273.0667],
			[-1843.2, 60.001, 682.6667],
			[204.8, 60.001, 819.2],
			[-1570.1334, 60.001, 955.7333],
			[204.8, 60.001, 1365.3333],
			[-1297.0667, 60.001, 1501.8667],
			[1160.5333, 60.001, 1501.8667],
			[1843.2, 60.001, 1638.4],
			[-68.2666, 60.001, 1774.9333],
			[-1706.6667, 60.001, 1911.4667],
			[1160.5333, 60.001, 1911.4667],
			[-1911.4667, 60.001, 341.3333], // skala 444 pion czerwony pastelowy
			[-1774.9334, 60.001, 341.3333],
			[-1501.8667, 60.001, -1024],
			[-1365.3334, 60.001, 1843.2],
			[-1365.3334, 60.001, -750.9333],
			[-1228.8, 60.001, 887.4667],
			[-819.2, 60.001, -1706.6667],
			[-682.6666, 60.001, 477.8667],
			[-682.6666, 60.001, -750.9333],
			[-546.1333, 60.001, -341.3333],
			[-409.6, 60.001, -614.4],
			[-273.0666, 60.001, 1706.6667],
			[-273.0666, 60.001, 341.3333],
			[-273.0666, 60.001, -1843.2],
			[273.0667, 60.001, 1024],
			[273.0667, 60.001, 341.3333],
			[273.0667, 60.001, -1843.2],
			[409.6, 60.001, 1433.6],
			[409.6, 60.001, -1297.0667],
			[546.1334, 60.001, 887.4667],
			[546.1334, 60.001, -1843.2],
			[819.2, 60.001, 750.9333],
			[955.7333, 60.001, 887.4667],
			[955.7333, 60.001, -68.2667],
			[955.7333, 60.001, -614.4],
			[1092.2667, 60.001, -1160.5333],
			[1228.8, 60.001, 1843.2],
			[1365.3333, 60.001, 68.2667],
			[1365.3333, 60.001, -887.4667],
			[1501.8667, 60.001, -68.2667],
			[1638.4, 60.001, 1706.6667],
			[1638.4, 60.001, -68.2667],
			[1638.4, 60.001, -955.7333], // skala 581 poziom fiolet pastelowy
			[819.2, 60.001, -546.1333],
			[-1092.2667, 60.001, -273.0667],
			[-682.6666, 60.001, 0],
			[1638.4, 60.001, 136.5333],
			[-1774.9333, 60.001, 409.6],
			[-682.6666, 60.001, 409.6],
			[-136.5333, 60.001, 546.1333],
			[-1365.3334, 60.001, 1638.4],
			[136.5334, 60.001, 1638.4],
			[-409.6, 60.001, 1911.4667],
			[-1365.3334, 60.001, 136.5333], // skala 581 pion turkus 
			[-955.7333, 60.001, 1228.8],
			[-273.0666, 60.001, 1092.2667],
			[-273.0666, 60.001, -819.2],
			[0, 60.001, 136.5333],
			[0, 60.001, -955.7333],
			[136.5334, 60.001, 546.1333],
			[273.0667, 60.001, -1092.2667],
			[546.1334, 60.001, 1501.8667],
			[1228.8, 60.001, 1228.8],
			[1228.8, 60.001, -1092.2667],
			[1638.4, 60.001, -819.2],
			[1774.9333, 60.001, -682.6667],
			[1911.4667, 60.001, -409.6],
			[1297.0667, 60.001, 409.6], // skala 717 poziom czarny
			[-68.2666, 60.001, 1501.8667],
			[-1911.4667, 60.001, 1160.5333], // skala 717 pion szary
			[-955.7333, 60.001, -887.4667],
			[-682.6666, 60.001, 1160.5333],
			[136.5334, 60.001, -887.4667],
			[1774.9333, 60.001, 614.4],
			[-819.2, 60.001, 1774.9333], // skala 854 poziom brązowy
			[-819.2, 60.001, 955.7333], // skala 854 pion wiśniowy 
			[1365.3333, 60.001, 1160.5333],// skala 990 xD ciemny niebieski
			[-1092.2667, 60.001, -2048], // skala 1946 poziom
			[1092.2667, 60.001, 2048],
			[1024, 60.001, -2048], // skala 2082 poziom
			[-1024, 60.001, 2048],
			[-2048, 60.001, 0], // skala 4131 pion
			[2048, 60.001, 0],
		];
		const boxes = [];
		let Acamera = camera;
		//Obsługa klawiatury
		document.addEventListener("keydown", function (event) {
			key[event.key] = true;
		});
		document.addEventListener("keyup", function (event) {
			if (event.key === 'F' || event.key === 'f') {
				fPressCtr++;
				if (fPressCtr % 2 == 0) {
					spotLight.intensity = 0;
					spotLight.power = 0;
				}
				else {
					spotLight.intensity = 0.5;
					spotLight.power = 840000;
				}
			}
			else if (event.key === 'C' || event.key === 'c') {
				cPressCtr++;
				if (cPressCtr % 2 == 0) {
					Acamera=camera;
				}
				else {
					Acamera = camera2;
				}
			}
			key[event.key] = false;
		});

		// Skybox

		scene.background = new THREE.CubeTextureLoader()
			.setPath("../assets/textures/forestv4/")
			.load(["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"]);

		// Światła

		const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);

		const spotLight = new THREE.SpotLight(0xffffff, 0, 350, Math.PI / 10, 0.8);

		spotLight.power = 0; // lumeny
		spotLight.shadow.mapSize.width = 1024;
		spotLight.shadow.mapSize.height = 1024;
		spotLight.castShadow = true;

		const shadowCamera = spotLight.shadow.camera; // redukcja 'rozlewania się' cieni
		shadowCamera.near = 1;
		shadowCamera.far = 350;
		shadowCamera.updateProjectionMatrix();

		
		// Mgła

		const fog = new THREE.FogExp2(0xcccccc, 0.008); // density default 0.00025
		scene.fog = fog;

		// Tekstury
		
		const groundT = new THREE.TextureLoader()
			.load("../assets/textures/Maze/groundT2.png");
		groundT.wrapS = THREE.RepeatWrapping;
		groundT.wrapT = THREE.RepeatWrapping;
		groundT.repeat.set(24, 24); // Zapętlanie tekstur, 15 horyzontalnie, 12 pionowo

		const hedgeT308 = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeT308.wrapS = THREE.RepeatWrapping;
		hedgeT308.wrapT = THREE.RepeatWrapping;
		hedgeT308.repeat.set(3, 1);

		const hedgeT440 = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeT440.wrapS = THREE.RepeatWrapping;
		hedgeT440.wrapT = THREE.RepeatWrapping;
		hedgeT440.repeat.set(3, 1);

		const hedgeT717 = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeT717.wrapS = THREE.RepeatWrapping;
		hedgeT717.wrapT = THREE.RepeatWrapping;
		hedgeT717.repeat.set(5, 1);

		const hedgeT990 = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeT990.wrapS = THREE.RepeatWrapping;
		hedgeT990.wrapT = THREE.RepeatWrapping;
		hedgeT990.repeat.set(8, 1);

		const hedgeT1946 = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeT1946.wrapS = THREE.RepeatWrapping;
		hedgeT1946.wrapT = THREE.RepeatWrapping;
		hedgeT1946.repeat.set(20, 1);

		const hedgeT1946Inv = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeT1946Inv.wrapS = THREE.RepeatWrapping;
		hedgeT1946Inv.wrapT = THREE.RepeatWrapping;
		hedgeT1946Inv.repeat.set(1, 50);

		const hedgeTS = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeTS.wrapS = THREE.RepeatWrapping;
		hedgeTS.wrapT = THREE.RepeatWrapping;
		hedgeTS.repeat.set(1, 1);

		const hedgeTY = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeTY.wrapS = THREE.RepeatWrapping;
		hedgeTY.wrapT = THREE.RepeatWrapping;
		hedgeTY.repeat.set(3, 1);

		const hedgeTYInV = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeTYInV.wrapS = THREE.RepeatWrapping;
		hedgeTYInV.wrapT = THREE.RepeatWrapping;
		hedgeTYInV.repeat.set(1, 3);

		const hedgeTY2 = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeTY2.wrapS = THREE.RepeatWrapping;
		hedgeTY2.wrapT = THREE.RepeatWrapping;
		hedgeTY2.repeat.set(8, 1);

		const hedgeTY990 = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeTY990.wrapS = THREE.RepeatWrapping;
		hedgeTY990.wrapT = THREE.RepeatWrapping;
		hedgeTY990.repeat.set(1, 12);

		const hedgeTY2Inv = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeFixedProbably.png");
		hedgeTY2Inv.wrapS = THREE.RepeatWrapping;
		hedgeTY2Inv.wrapT = THREE.RepeatWrapping;
		hedgeTY2Inv.repeat.set(1, 8);

		const hedgeThelpX = new THREE.TextureLoader()
			.load("../assets/textures/Maze/hedgeX.png");
		hedgeThelpX.wrapS = THREE.RepeatWrapping;
		hedgeThelpX.wrapT = THREE.RepeatWrapping;
		hedgeThelpX.repeat.set(1, 1);

		const faceMaterialCube = new THREE.MeshStandardMaterial({
			color: 'red'
		});

		// Geometrie i hitboxy

		const ground = new THREE.Mesh(new THREE.PlaneGeometry(4131, 4131), new THREE.MeshStandardMaterial({
			side: THREE.DoubleSide,
			map: groundT
		}));
		ground.receiveShadow = true;

		const cubeG = new THREE.BoxGeometry(24, 70, 24);
		cubeG.computeBoundingBox();
		let cube = new THREE.Mesh(cubeG, faceMaterialCube);
		cube.position.set(-68.27, 35.001, -2048);
		cubeG.userData.obb = new OBBJs.OBB().fromBox3(cubeG.boundingBox); // Oriented Bounding Box na geometrii
		cube.userData.obb = new OBBJs.OBB(); // i na obiekcie

		
		camera2.lookAt(cube.position);
		camera2.position.copy(cube.position);

		const hedgeG = new THREE.BoxGeometry(120, 120, 120);

		const Hmesh1 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 124); // 136 poziom
		const Hmesh2 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 118); // 136 pion
		const Hmesh3 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 69); // 273 poziom
		const Hmesh4 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 56); // 273 pion
		const Hmesh5 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 33); // 409 poziom
		const Hmesh6 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 32); // 409 pion
		const Hmesh7 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 11); // 546 poziom
		const Hmesh8 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 14); // 546 pion
		const Hmesh9 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 2); // 682 poziom
		const Hmesh10 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 5); // 682 pion
		const Hmesh11 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 1); // 819 poziom
		const Hmesh12 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 1); // 819 pion
		const Hmesh13 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 1); // 955 pion
		const Hmesh14 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 2); // 1911 poziom
		const Hmesh15 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 2); // 2048 poziom
		const Hmesh16 = new THREE.InstancedMesh(hedgeG, new THREE.MeshStandardMaterial(), 2); // 4096 pion

		/*
		Instanced Mesh charakteryzuje się tą samą geometrią i meshem ale o różnych transformacjach,
		traktowana jako grupa obiektów jest wywoływana w kodzie raz, co optymalizuje go wydajnościowo
		*/

		for (let i = 0; i < positions.length; i++) {

			const matrix = new THREE.Matrix4(); // informacje o każdej transformacji są zbierane do macierzy

			if (i >= 0 && i < 124) matrix.makeScale(skala171, 1, skalaS); // skala171 poziom
			else if (i > 123 && i < 242) matrix.makeScale(skalaS, 1, skala171); // skala171 pion
			else if (i > 241 && i < 311) matrix.makeScale(skala308, 1, skalaS); // skala308 poziom
			else if (i > 310 && i < 367) matrix.makeScale(skalaS, 1, skala308); // skala308 pion
			else if (i > 366 && i < 400) matrix.makeScale(skala444, 1, skalaS); // skala444 poziom
			else if (i > 399 && i < 432) matrix.makeScale(skalaS, 1, skala444); // skala444 pion
			else if (i > 431 && i < 443) matrix.makeScale(skala581, 1, skalaS); // skala581 poziom
			else if (i > 442 && i < 457) matrix.makeScale(skalaS, 1, skala581); // skala581 pion
			else if (i > 456 && i < 459) matrix.makeScale(skala717, 1, skalaS); // skala717 poziom
			else if (i > 458 && i < 464) matrix.makeScale(skalaS, 1, skala717); // skala717 pion
			else if (i == 464) matrix.makeScale(skala854, 1, skalaS); // skala854 poziom
			else if (i == 465) matrix.makeScale(skalaS, 1, skala854); // skala854 pion
			else if (i == 466) matrix.makeScale(skalaS, 1, skala990); // skala 955 pion
			else if (i > 466 && i < 469) matrix.makeScale(skala1946, 1, skalaS); // skala1946 poziom
			else if (i > 468 && i < 471) matrix.makeScale(skala2083, 1, skalaS); // skala2083 poziom
			else matrix.makeScale(skalaS, 1, skala4131); // skala4131 pion

			matrix.setPosition(positions[i][0], positions[i][1], positions[i][2]);
			matrix.needsUpdate = true;

			if (i >= 0 && i < 124) {
				Hmesh1.setMatrixAt(ctr1, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh1);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr1++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeTS,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeTS,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh1.material = faceMaterial;
				Hmesh1.receiveShadow = true;
				Hmesh1.castShadow = true;
				Hmesh1.material.needsUpdate = true;
			}
			else if (i > 123 && i < 242) {
				Hmesh2.setMatrixAt(ctr2, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh2);
				box.applyMatrix4(matrix);
				boxes.push(box);
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeTS,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeTS,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTYInV,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTYInV,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh2.material = faceMaterial;
				Hmesh2.receiveShadow = true;
				Hmesh2.castShadow = true;
				Hmesh2.material.needsUpdate = true;
				ctr2++;
			}
			else if (i > 241 && i < 311) {
				Hmesh3.setMatrixAt(ctr3, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh3);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr3++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeT308,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeT308,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh3.material = faceMaterial;
				Hmesh3.receiveShadow = true;
				Hmesh3.castShadow = true;
				Hmesh3.material.needsUpdate = true;
			}
			else if (i > 310 && i < 367) {
				Hmesh4.setMatrixAt(ctr4, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh4);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr4++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeT308,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeT308,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTYInV,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTYInV,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh4.material = faceMaterial;
				Hmesh4.receiveShadow = true;
				Hmesh4.castShadow = true;
				Hmesh4.material.needsUpdate = true;
			}
			else if (i > 366 && i < 400) {
				Hmesh5.setMatrixAt(ctr5, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh5);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr5++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY2,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY2,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeT440,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeT440,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh5.material = faceMaterial;
				Hmesh5.receiveShadow = true;
				Hmesh5.castShadow = true;
				Hmesh5.material.needsUpdate = true;
			}
			else if (i > 399 && i < 432) {
				Hmesh6.setMatrixAt(ctr6, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh6);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr6++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeT440,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeT440,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY2Inv,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY2Inv,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh6.material = faceMaterial;
				Hmesh6.receiveShadow = true;
				Hmesh6.castShadow = true;
				Hmesh6.material.needsUpdate = true;
			}
			else if (i > 431 && i < 443) {
				Hmesh7.setMatrixAt(ctr7, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh7);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr7++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY2,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY2,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeT440,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeT440,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh7.material = faceMaterial;
				Hmesh7.receiveShadow = true;
				Hmesh7.castShadow = true;
				Hmesh7.material.needsUpdate = true;
			}
			else if (i > 442 && i < 457) {
				Hmesh8.setMatrixAt(ctr8, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh8);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr8++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeT440,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeT440,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY2Inv,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY2Inv,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh8.material = faceMaterial;
				Hmesh8.receiveShadow = true;
				Hmesh8.castShadow = true;
				Hmesh8.material.needsUpdate = true;
			}
			else if (i > 456 && i < 459) {
				Hmesh9.setMatrixAt(ctr9, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh9);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr9++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY2,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY2,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeT717,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeT717,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh9.material = faceMaterial;
				Hmesh9.receiveShadow = true;
				Hmesh9.castShadow = true;
				Hmesh9.material.needsUpdate = true;
			}
			else if (i > 458 && i < 464) {
				Hmesh10.setMatrixAt(ctr10, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh10);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr10++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeT717,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeT717,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY2Inv,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY2Inv,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh10.material = faceMaterial;
				Hmesh10.receiveShadow = true;
				Hmesh10.castShadow = true;
				Hmesh10.material.needsUpdate = true;
			}
			else if (i == 464) {
				Hmesh11.setMatrixAt(ctr11, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh11);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr11++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY2,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY2,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeT717,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeT717,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh11.material = faceMaterial;
				Hmesh11.receiveShadow = true;
				Hmesh11.castShadow = true;
				Hmesh11.material.needsUpdate = true;
			}
			else if (i == 465) {
				Hmesh12.setMatrixAt(ctr12, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh12);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr12++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeT717,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeT717,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY2Inv,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY2Inv,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh12.material = faceMaterial;
				Hmesh12.receiveShadow = true;
				Hmesh12.castShadow = true;
				Hmesh12.material.needsUpdate = true;
			}
			else if (i == 466) {
				Hmesh13.setMatrixAt(ctr13, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh13);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr13++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeT990,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeT990,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeTY990,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeTY990,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh13.material = faceMaterial;
				Hmesh13.receiveShadow = true;
				Hmesh13.castShadow = true;
				Hmesh13.material.needsUpdate = true;
			}
			else if (i > 466 && i < 469) {
				Hmesh14.setMatrixAt(ctr14, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh14);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr14++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeT1946,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeT1946,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeT1946,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeT1946,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh14.material = faceMaterial;
				Hmesh14.receiveShadow = true;
				Hmesh14.castShadow = true;
				Hmesh14.material.needsUpdate = true;
			}
			else if (i > 468 && i < 471) {
				Hmesh15.setMatrixAt(ctr15, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh15);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr15++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeT1946,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeT1946,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeT1946,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeT1946,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh15.material = faceMaterial;
				Hmesh15.receiveShadow = true;
				Hmesh15.castShadow = true;
				Hmesh15.material.needsUpdate = true;
			}
			else {
				Hmesh16.setMatrixAt(ctr16, matrix);
				let box = new THREE.Box3().setFromObject(Hmesh16);
				box.applyMatrix4(matrix);
				boxes.push(box);
				ctr16++;
				const faceMaterial = [
					new THREE.MeshStandardMaterial({
						map: hedgeT1946,
						metalness: metal,
						roughness: rough
					}), // positive x
					new THREE.MeshStandardMaterial({
						map: hedgeT1946,
						metalness: metal,
						roughness: rough
					}), // negative x
					new THREE.MeshStandardMaterial({
						map: hedgeT1946Inv,
						metalness: metal,
						roughness: rough
					}), // positive y
					new THREE.MeshStandardMaterial({
						map: hedgeT1946Inv,
						metalness: metal,
						roughness: rough
					}), // negative y
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // positive z
					new THREE.MeshStandardMaterial({
						map: hedgeThelpX,
						metalness: metal,
						roughness: rough
					}), // negative z
				];
				Hmesh16.material = faceMaterial;
				Hmesh16.receiveShadow = true;
				Hmesh16.castShadow = true;
				Hmesh16.material.needsUpdate = true;
			}
		}

		// Dodanie do grup i pozycje obiektów

		rotate.add(ground);
		scene.add(rotate);
		scene.add(Hmesh1, Hmesh2, Hmesh3, Hmesh4, Hmesh5, Hmesh6, Hmesh7, Hmesh8, Hmesh9, Hmesh10, Hmesh11, Hmesh12, Hmesh13, Hmesh14, Hmesh15, Hmesh16);
		scene.add(cube);
		scene.add(ambientLight);
		scene.add(spotLight);
		scene.add(spotLight.target);

		camera.position.y += 45;
		camera.position.z = cube.position.z - 75;
		camera.position.x = cube.position.x;
		cube.rotation.y = -Math.PI;
		camera.rotation.y = -Math.PI;
		rotate.rotation.x = -Math.PI / 2;

		
		controls.update();
		function updateBox() {
			cube.userData.obb.copy(cube.geometry.userData.obb);
			cube.userData.obb.applyMatrix4(cube.matrixWorld);
		}

		function updateCamera() {
			camera.position.copy(cube.position);
			camera.quaternion.copy(cube.quaternion);
		}

		function updateSpotlight() {
			spotLight.position.copy(cube.position);
			let direction = new THREE.Vector3(0, 0, -1);
			direction.applyQuaternion(cube.quaternion);
			direction.normalize();
			direction.multiplyScalar(1);
			spotLight.target.position.copy(cube.position.clone().add(direction))
			/*
			Tworzymy wektor kierunkowy na negatywne z, dodajemy kwaterion naszego obiektu i normalizujemy
			aby mieć pewność że dalej jest wektorem jednostkowym, mnożymy go przez 1 aby przesunąć go do przodu o 1 jednostkę i kopiujemy
			go na pozycję targetu spotLight żeby świecił nam w kierunku ruchu
			*/
		}

		function pushAway(pushFrom) {
			let distance = cube.position.distanceTo(pushFrom); // dystans między środkami obiektów (float)
			let howFar = 0;
			if (distance < 165) { //skala 171
				howFar = distance / 2;
			}
			else if (distance > 164 && distance < 168) { //close to 48,75 308
				howFar = distance / 4;
			}
			else if (distance > 232 && distance < 236) { // 444
				howFar = distance / 5;
			}
			else if (distance > 300 && distance < 305) { // 581
				howFar = distance / 7;
			}
			else if (distance > 368 && distance < 372) { // 717
				howFar = distance / 8;
			}
			else if (distance > 437 && distance < 441) { // 854
				howFar = distance / 9;
			}
			else if (distance > 505 && distance < 509) { // 990
				howFar = distance / 11;
			}
			else if (distance > 983 && distance < 987) { // 1946
				howFar = distance / 20;
			}
			else if (distance > 1051 && distance < 1055) { // 2083
				howFar = distance / 22;
			}
			else if (distance > 2075 && distance < 2079) { // 4131
				howFar = distance / 43;
			}
			let pushDir = cube.position.clone()
				.sub(pushFrom)
				.normalize(); // normalna do kierunku wypchnięcia obiektu
			cube.position.set(cube.position.x + pushDir.x * howFar, cube.position.y, cube.position.z + pushDir.z * howFar);
		}

		function checkCollision() {
			for (let i = 0; i < boxes.length; i++) {
				if (cube.userData.obb.intersectsBox3(boxes[i])) {
					let center = new THREE.Vector3();
					boxes[i].getCenter(center);
					const pushFrom = center;
					pushAway(pushFrom);
				}
			}
		}

		animate();

		function renderScene() {
			renderer.render(scene, Acamera);
		}

		function animate() {
			requestAnimationFrame(animate);
			controls.update();
			updateBox();
			updateCamera();
			updateSpotlight();
			checkCollision();
			keyboard();
			renderScene();
		}

		function keyboard() {
			if (key['ArrowUp']) {
				const direction = new THREE.Vector3();
				cube.getWorldDirection(direction).negate(); //zbiera info o kierunku positive z obiektu, neguje i wysyła do wektora
				cube.position.add(direction.multiplyScalar(speedFactor));
			}
			if (key['ArrowDown']) {
				const direction = new THREE.Vector3();
				cube.getWorldDirection(direction);
				cube.position.add(direction.multiplyScalar(speedFactor));

			}
			if (key['ArrowLeft']) {
				const direction = new THREE.Vector3();
				cube.rotation.y += rotSpeed;
			}
			if (key['ArrowRight']) {
				const direction = new THREE.Vector3();
				cube.rotation.y -= rotSpeed;
			}
		}
	</script>
</head>

<body>
</body>

</html>