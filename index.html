<!DOCTYPE html>
<html lang="pl-PL">
  <head>
    <title>Labirynt - Final Fixed</title>
    <meta charset="UTF-8" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OBB } from "three/addons/math/OBB.js";

      // --- KONFIGURACJA ŚWIATA ---
      const WALL_SIZE = 120; // Rozmiar jednego klocka ściany (szer/dł/wys)
      const MAZE_WIDTH = 31; // Musi być liczbą nieparzystą dla tego algorytmu
      const MAZE_HEIGHT = 31;

      // Setup Sceny
      const scene = new THREE.Scene();
      // UWAGA: Zwiększyłem 'near' z 0.1 do 1.5, żeby naprawić z-fighting
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        1.5,
        3000
      );
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        logarithmicDepthBuffer: true,
      });
      const cameraRaycaster = new THREE.Raycaster();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // --- TEXTURY I MATERIAŁY ---
      const texLoader = new THREE.TextureLoader();
      const loadTex = (path, repeatX = 1, repeatY = 1) => {
        const t = texLoader.load(path);
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        t.repeat.set(repeatX, repeatY);
        return t;
      };

      const texGround = loadTex("/assets/textures/Maze/groundT2.png", 24, 24);
      const texHedgeBase = loadTex(
        "/assets/textures/Maze/hedgeFixedProbably.png"
      );
      const texHedgeX = loadTex("/assets/textures/Maze/hedgeX.png");

      scene.background = new THREE.CubeTextureLoader()
        .setPath("/assets/textures/forestv4/")
        .load(["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"]);
      scene.fog = new THREE.FogExp2(0xcccccc, 0.008);

      const createMaterials = (repX, repY) => {
        const matProps = { metalness: 0, roughness: 1 };
        const sideMat = new THREE.MeshStandardMaterial({
          ...matProps,
          map: texHedgeBase.clone(),
        });
        sideMat.map.repeat.set(repX, repY);

        const endMat = new THREE.MeshStandardMaterial({
          ...matProps,
          map: texHedgeX,
        });
        const topMat = new THREE.MeshStandardMaterial({
          ...matProps,
          map: texHedgeBase.clone(),
        });

        return [endMat, endMat, topMat, topMat, sideMat, sideMat];
      };

      // --- BUDOWANIE ŚWIATA ---

      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(4131, 4131),
        new THREE.MeshStandardMaterial({
          map: texGround,
          side: THREE.DoubleSide,
        })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const playerGeo = new THREE.BoxGeometry(24, 70, 24);
      playerGeo.computeBoundingBox(); // WAŻNE: Naprawia błąd 'null' w OBB
      playerGeo.userData.obb = new OBB().fromBox3(playerGeo.boundingBox);
      const player = new THREE.Mesh(
        playerGeo,
        new THREE.MeshStandardMaterial({ color: "red" })
      );
      player.position.set(-68.27, 35.001, -2048);
      player.userData.obb = new OBB();
      scene.add(player);

      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const spotLight = new THREE.SpotLight(
        0xffffff,
        0,
        350,
        Math.PI / 10,
        0.8
      );
      spotLight.castShadow = true;
      spotLight.shadow.mapSize.width = 1024;
      spotLight.shadow.mapSize.height = 1024;
      scene.add(spotLight);
      scene.add(spotLight.target);

      // --- GENEROWANIE LABIRYNTU (NOWE) ---
      const mazeMap = generateMaze(MAZE_WIDTH, MAZE_HEIGHT);
      const collisionBoxes = [];
      const wallMeshes = []; // Dla kamery

      // Geometria - prosty sześcian
      const geometry = new THREE.BoxGeometry(WALL_SIZE, WALL_SIZE, WALL_SIZE);

      // Materiał - używamy Twoich tekstur, ale uproszczonych
      // Skoro każdy klocek jest 1x1, nie potrzebujemy dynamicznego skalowania tekstury per segment
      const matSide = new THREE.MeshStandardMaterial({ map: texHedgeBase });
      const matTop = new THREE.MeshStandardMaterial({ map: texHedgeX }); // Lub inna tekstura na górę
      const materials = [matSide, matSide, matTop, matTop, matSide, matSide];

      // Policz ile jest ścian, żeby stworzyć InstancedMesh o odpowiednim rozmiarze
      let wallCount = 0;
      for (let x = 0; x < MAZE_WIDTH; x++) {
        for (let y = 0; y < MAZE_HEIGHT; y++) {
          if (mazeMap[x][y] === 1) wallCount++;
        }
      }

      const mesh = new THREE.InstancedMesh(geometry, materials, wallCount);
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      const dummy = new THREE.Object3D();
      let i = 0;

      // Offset, żeby labirynt był wycentrowany wokół (0,0) - tak jak w Twoim oryginale
      const offsetX = (MAZE_WIDTH * WALL_SIZE) / 2;
      const offsetZ = (MAZE_HEIGHT * WALL_SIZE) / 2;

      for (let x = 0; x < MAZE_WIDTH; x++) {
        for (let z = 0; z < MAZE_HEIGHT; z++) {
          if (mazeMap[x][z] === 1) {
            // Ustawienie pozycji
            dummy.position.set(
              x * WALL_SIZE - offsetX,
              WALL_SIZE / 2, // Y: połowa wysokości, żeby stał na ziemi
              z * WALL_SIZE - offsetZ
            );

            dummy.updateMatrix();
            mesh.setMatrixAt(i++, dummy.matrix);

            // Kolizje
            const instanceBox = new THREE.Box3();
            instanceBox.setFromCenterAndSize(
              dummy.position,
              new THREE.Vector3(WALL_SIZE, WALL_SIZE, WALL_SIZE)
            );
            collisionBoxes.push(instanceBox);
          }
        }
      }

      scene.add(mesh);
      wallMeshes.push(mesh); // Ważne dla kamery

      // --- LOGIKA GRY ---
      const keys = {};
      const speed = 4.0;
      const rotSpeed = 0.04;
      const prevPos = new THREE.Vector3();

      window.addEventListener("keydown", (e) => (keys[e.code] = true));
      window.addEventListener("keyup", (e) => {
        keys[e.code] = false;
        if (e.key.toLowerCase() === "f") {
          spotLight.power = spotLight.power > 0 ? 0 : 840000;
          spotLight.intensity = spotLight.intensity > 0 ? 0 : 0.5;
        }
      });

      function generateMaze(width, height) {
        // 1. Wypełnij wszystko ścianami (1)
        const map = [];
        for (let x = 0; x < width; x++) {
          map[x] = [];
          for (let y = 0; y < height; y++) {
            map[x][y] = 1;
          }
        }

        // 2. Funkcja wiercąca korytarze (Recursive Backtracker)
        function carve(x, y) {
          const directions = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ].sort(() => Math.random() - 0.5); // Losowa kolejność kierunków

          for (let i = 0; i < directions.length; i++) {
            const dx = directions[i][0];
            const dy = directions[i][1];

            const nx = x + dx * 2;
            const ny = y + dy * 2;

            if (
              nx > 0 &&
              nx < width &&
              ny > 0 &&
              ny < height &&
              map[nx][ny] === 1
            ) {
              map[x + dx][y + dy] = 0; // Usuń ścianę pomiędzy
              map[nx][ny] = 0; // Usuń ścianę w punkcie docelowym
              carve(nx, ny); // Rekurencja
            }
          }
        }

        // Start z punktu (1,1) i oznacz jako pusty
        map[1][1] = 0;
        carve(1, 1);

        // Opcjonalnie: Zrób wejście i wyjście
        map[1][0] = 0;
        map[width - 2][height - 1] = 0;

        return map;
      }

      function updatePlayer() {
        prevPos.copy(player.position);

        if (keys["ArrowUp"]) player.translateZ(-speed);
        if (keys["ArrowDown"]) player.translateZ(speed);
        if (keys["ArrowLeft"]) player.rotation.y += rotSpeed;
        if (keys["ArrowRight"]) player.rotation.y -= rotSpeed;

        player.updateMatrixWorld();
        player.userData.obb.copy(playerGeo.userData.obb);
        player.userData.obb.applyMatrix4(player.matrixWorld);

        for (const wallBox of collisionBoxes) {
          if (player.userData.obb.intersectsBox3(wallBox)) {
            player.position.copy(prevPos);
            // Nie używamy return, żeby kamera nadal się aktualizowała nawet jak stoimy w miejscu
            break;
          }
        }

        // --- KAMERA I RAYCASTING (POPRAWIONE) ---
        const idealOffset = new THREE.Vector3(0, 45, 75);
        idealOffset.applyAxisAngle(
          new THREE.Vector3(0, 1, 0),
          player.rotation.y
        );
        const idealPosition = new THREE.Vector3()
          .copy(player.position)
          .add(idealOffset);

        const playerHeadPos = new THREE.Vector3()
          .copy(player.position)
          .add(new THREE.Vector3(0, 30, 0));
        const direction = new THREE.Vector3()
          .subVectors(idealPosition, playerHeadPos)
          .normalize();
        const maxDistance = playerHeadPos.distanceTo(idealPosition);

        cameraRaycaster.set(playerHeadPos, direction);
        cameraRaycaster.far = maxDistance;

        const intersects = cameraRaycaster.intersectObjects(wallMeshes);

        if (intersects.length > 0) {
          const hitPoint = intersects[0].point;
          const buffer = direction.clone().multiplyScalar(-2.0);
          camera.position.copy(hitPoint).add(buffer);
        } else {
          camera.position.copy(idealPosition);
        }

        const lookTarget = player.position
          .clone()
          .add(new THREE.Vector3(0, 20, 0));
        camera.lookAt(lookTarget);

        spotLight.position.copy(player.position);
        spotLight.target.position
          .copy(player.position)
          .add(new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion));
        spotLight.target.updateMatrixWorld();
      }

      function animate() {
        requestAnimationFrame(animate);
        updatePlayer();
        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </head>
  <body></body>
</html>
