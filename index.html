<!DOCTYPE html>
<html lang="pl-PL">
  <head>
    <title>Labirynt - FPP/TPP Toggle</title>
    <meta charset="UTF-8" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OBB } from "three/addons/math/OBB.js";

      // --- ZMIENNE GLOBALNE ---
      let lastButtonState = false;  // Latarka (Pad)
      let lastCamBtnState = false;  // Kamera (Pad)
      let lastKeyFState = false;    // Latarka (Klawiatura)
      let lastKeyCState = false;    // Kamera (Klawiatura)
      
      let isFPP = false;            // Startujemy w TPP

      const keys = {};

      // --- KONFIGURACJA ---
      const WALL_SIZE = 120;
      const MAZE_WIDTH = 21;
      const MAZE_HEIGHT = 21;
      const OFFSET_X = (MAZE_WIDTH * WALL_SIZE) / 2;
      const OFFSET_Z = (MAZE_HEIGHT * WALL_SIZE) / 2;

      // --- SETUP SCENY ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1.5, 5000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
      const cameraRaycaster = new THREE.Raycaster();
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // --- TEXTURY ---
      const texLoader = new THREE.TextureLoader();
      const texGround = texLoader.load("/assets/textures/Maze/groundT2.png");
      texGround.wrapS = texGround.wrapT = THREE.RepeatWrapping;
      texGround.repeat.set(MAZE_WIDTH, MAZE_HEIGHT);
      const texHedgeBase = texLoader.load("/assets/textures/Maze/hedgeFixedProbably.png");
      const texHedgeX = texLoader.load("/assets/textures/Maze/hedgeX.png");

      scene.background = new THREE.Color(0x111111);
      scene.fog = new THREE.FogExp2(0x111111, 0.002);

      // --- GENERATOR LABIRYNTU ---
      function generateMaze(width, height) {
         const map = [];
         for (let x = 0; x < width; x++) { map[x] = []; for (let y = 0; y < height; y++) map[x][y] = 1; }
         function carve(x, y) {
            const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]].sort(() => Math.random() - 0.5);
            for (let i = 0; i < directions.length; i++) {
               const nx = x + directions[i][0] * 2, ny = y + directions[i][1] * 2;
               if (nx > 0 && nx < width && ny > 0 && ny < height && map[nx][ny] === 1) {
                  map[x + directions[i][0]][y + directions[i][1]] = 0; map[nx][ny] = 0; carve(nx, ny);
               }
            }
         }
         map[1][1] = 0; carve(1, 1);
         map[1][0] = 0; map[width - 2][height - 1] = 0;
         return map;
      }
      const mazeMap = generateMaze(MAZE_WIDTH, MAZE_HEIGHT);

      // --- BUDOWANIE ŚWIATA ---
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(MAZE_WIDTH * WALL_SIZE, MAZE_HEIGHT * WALL_SIZE),
        new THREE.MeshStandardMaterial({ map: texGround, side: THREE.DoubleSide })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const geometry = new THREE.BoxGeometry(WALL_SIZE, WALL_SIZE, WALL_SIZE);
      const matSide = new THREE.MeshStandardMaterial({ map: texHedgeBase });
      const matTop = new THREE.MeshStandardMaterial({ map: texHedgeX });
      const materials = [matSide, matSide, matTop, matTop, matSide, matSide];
      
      let wallCount = 0;
      for (let x = 0; x < MAZE_WIDTH; x++) for (let y = 0; y < MAZE_HEIGHT; y++) if (mazeMap[x][y] === 1) wallCount++;
      const mesh = new THREE.InstancedMesh(geometry, materials, wallCount);
      mesh.castShadow = true; mesh.receiveShadow = true;
      
      const collisionBoxes = []; 
      const wallMeshes = [mesh];
      const dummy = new THREE.Object3D(); 
      let index = 0;

      for (let x = 0; x < MAZE_WIDTH; x++) {
          for (let z = 0; z < MAZE_HEIGHT; z++) {
              if (mazeMap[x][z] === 1) {
                  const worldX = x * WALL_SIZE - OFFSET_X + WALL_SIZE / 2;
                  const worldZ = z * WALL_SIZE - OFFSET_Z + WALL_SIZE / 2;
                  dummy.position.set(worldX, WALL_SIZE / 2, worldZ);
                  dummy.updateMatrix();
                  mesh.setMatrixAt(index++, dummy.matrix);
                  const box = new THREE.Box3();
                  box.setFromCenterAndSize(dummy.position, new THREE.Vector3(WALL_SIZE, WALL_SIZE, WALL_SIZE));
                  collisionBoxes.push(box);
              }
          }
      }
      scene.add(mesh);

      // --- GRACZ ---
      const playerGeo = new THREE.BoxGeometry(24, 70, 24);
      playerGeo.computeBoundingBox();
      playerGeo.userData.obb = new OBB().fromBox3(playerGeo.boundingBox);
      const player = new THREE.Mesh(playerGeo, new THREE.MeshStandardMaterial({ color: "red" }));
      player.castShadow = true; 
      player.position.set(1 * WALL_SIZE - OFFSET_X + WALL_SIZE / 2, 35.001, 1 * WALL_SIZE - OFFSET_Z + WALL_SIZE / 2);
      player.userData.obb = new OBB();
      scene.add(player);

      // --- LATARKA ---
      scene.add(new THREE.AmbientLight(0xffffff, 0.01)); 
      const flashlight = new THREE.SpotLight(0xffffff, 180);
      flashlight.angle = Math.PI / 5;
      flashlight.penumbra = 0.3;
      flashlight.decay = 1.5;
      flashlight.distance = 4000;
      flashlight.castShadow = true;
      scene.add(flashlight);
      scene.add(flashlight.target);

      // --- STEROWANIE ---
      const maxSpeed = 5.0;
      const rotSpeed = 0.05;
      const prevPos = new THREE.Vector3();

      window.addEventListener("keydown", (e) => (keys[e.code] = true));
      window.addEventListener("keyup", (e) => (keys[e.code] = false));

      // Funkcja pomocnicza do obsługi klawiszy toggle (żeby nie mrugały)
      function handleToggle(isPressed, lastState, callback) {
          if (isPressed) {
              if (!lastState) {
                  callback();
                  return true; // Nowy stan lastState
              }
              return true; // Utrzymaj true
          }
          return false; // Zresetuj lastState
      }

      function getInputs() {
        let move = 0;
        let turn = 0;
        let toggleLight = false;
        let toggleCamera = false;

        // --- KLAWIATURA ---
        if (keys["ArrowUp"] || keys["KeyW"]) move = -1;
        if (keys["ArrowDown"] || keys["KeyS"]) move = 1;
        if (keys["ArrowLeft"] || keys["KeyA"]) turn = 1;
        if (keys["ArrowRight"] || keys["KeyD"]) turn = -1;
        
        // Latarka (F)
        if (keys["KeyF"]) {
             if (!lastKeyFState) { toggleLight = true; lastKeyFState = true; }
        } else { lastKeyFState = false; }

        // Kamera (C)
        if (keys["KeyC"]) {
             if (!lastKeyCState) { toggleCamera = true; lastKeyCState = true; }
        } else { lastKeyCState = false; }

        // --- GAMEPAD ---
        const gamepads = navigator.getGamepads();
        const gp = gamepads ? gamepads[0] : null;

        if (gp) {
            const deadzone = 0.1;
            if (Math.abs(gp.axes[1]) > deadzone) move = gp.axes[1];
            if (Math.abs(gp.axes[0]) > deadzone) turn = -gp.axes[0];

            // Przycisk A (0) - Latarka
            const btnA = gp.buttons[0].pressed || gp.buttons[1].pressed; // Zabezpieczenie dla różnych padów
            if (btnA) {
                if (!lastButtonState) { toggleLight = true; lastButtonState = true; }
            } else { lastButtonState = false; }

            // Przycisk Y (3) - Kamera (Na Xbox to 'Y', na PS to Trójkąt)
            const btnY = gp.buttons[3].pressed; 
            if (btnY) {
                if (!lastCamBtnState) { toggleCamera = true; lastCamBtnState = true; }
            } else { lastCamBtnState = false; }
        }
        return { move, turn, toggleLight, toggleCamera };
      }

      function updatePlayer() {
        const inputs = getInputs();

        // 1. Zmiana Kamery FPP/TPP
        if (inputs.toggleCamera) {
            isFPP = !isFPP;
        }

        // Ukrywamy gracza w FPP, żeby nie zasłaniał widoku
        player.visible = !isFPP; 

        // 2. Ruch
        prevPos.copy(player.position);
        if (inputs.move !== 0) player.translateZ(inputs.move * maxSpeed);
        if (inputs.turn !== 0) player.rotation.y += inputs.turn * rotSpeed;

        // 3. Kolizje Gracza
        player.updateMatrixWorld();
        player.userData.obb.copy(playerGeo.userData.obb);
        player.userData.obb.applyMatrix4(player.matrixWorld);

        for (const wallBox of collisionBoxes) {
            if (wallBox.getCenter(new THREE.Vector3()).distanceTo(player.position) > WALL_SIZE * 1.5) continue;
            if (player.userData.obb.intersectsBox3(wallBox)) {
                player.position.copy(prevPos);
                break; 
            }
        }

        // -----------------------------------------------------
        // 4. LOGIKA KAMERY (ROZDZIELONA NA FPP i TPP)
        // -----------------------------------------------------
        
        if (isFPP) {
            // --- TRYB PIERWSZOOSOBOWY (FPP) ---
            
            // Kamera jest w miejscu głowy gracza
            const headPos = player.position.clone().add(new THREE.Vector3(0, 30, 0));
            camera.position.copy(headPos);
            
            // Kamera patrzy tam gdzie gracz, ale lekko w dół/środek (jak w FPS)
            // Używamy tego samego celu co w TPP dla spójności
            const lookTarget = player.position.clone().add(new THREE.Vector3(0, 30, -100).applyQuaternion(player.quaternion));
            camera.lookAt(lookTarget);

        } else {
            // --- TRYB TRZECIOOSOBOWY (TPP) - z kolizjami ---
            
            const idealOffset = new THREE.Vector3(0, 45, 75).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
            const idealPosition = new THREE.Vector3().copy(player.position).add(idealOffset);
            const playerHeadPos = new THREE.Vector3().copy(player.position).add(new THREE.Vector3(0, 30, 0));
            
            const direction = new THREE.Vector3().subVectors(idealPosition, playerHeadPos).normalize();
            const maxDist = playerHeadPos.distanceTo(idealPosition);

            cameraRaycaster.set(playerHeadPos, direction);
            cameraRaycaster.far = maxDist;

            const intersects = cameraRaycaster.intersectObjects(wallMeshes);
            let finalCameraPos = idealPosition;

            if (intersects.length > 0) {
                finalCameraPos = intersects[0].point.add(direction.multiplyScalar(-2.0));
            }

            camera.position.lerp(finalCameraPos, 0.2);
            camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 20, 0)));
        }

        // -----------------------------------------------------

        // 5. Latarka
        if (inputs.toggleLight) {
            flashlight.intensity = (flashlight.intensity > 0) ? 0 : 180;
        }

        flashlight.position.copy(player.position);
        flashlight.position.y += 20; 
        const forwardShift = new THREE.Vector3(0, 0, -15).applyQuaternion(player.quaternion);
        flashlight.position.add(forwardShift);

        flashlight.target.position.copy(player.position).add(
            new THREE.Vector3(0, -10, -100).applyQuaternion(player.quaternion)
        );
        flashlight.target.updateMatrixWorld();
      }

      function animate() {
        requestAnimationFrame(animate);
        updatePlayer();
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </head>
  <body></body>
</html>