<!DOCTYPE html>
<html lang="pl-PL">
  <head>
    <title>Labirynt - Procedural Grid</title>
    <meta charset="UTF-8" />
    <style>body { margin: 0; overflow: hidden; }</style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OBB } from "three/addons/math/OBB.js";

      // --- KONFIGURACJA ---
      const WALL_SIZE = 120;  // Rozmiar jednego klocka
      const MAZE_WIDTH = 21;  // Szerokość (musi być nieparzysta!)
      const MAZE_HEIGHT = 21; // Wysokość (musi być nieparzysta!)
      
      // Obliczamy przesunięcie, żeby labirynt był wycentrowany na (0,0,0)
      const OFFSET_X = (MAZE_WIDTH * WALL_SIZE) / 2;
      const OFFSET_Z = (MAZE_HEIGHT * WALL_SIZE) / 2;

      // --- SETUP SCENY ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1.5, 5000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
      const cameraRaycaster = new THREE.Raycaster();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // --- TEXTURY ---
      const texLoader = new THREE.TextureLoader();
      const texGround = texLoader.load("/assets/textures/Maze/groundT2.png");
      texGround.wrapS = texGround.wrapT = THREE.RepeatWrapping;
      texGround.repeat.set(MAZE_WIDTH, MAZE_HEIGHT); // Dopasowanie do rozmiaru labiryntu

      const texHedgeBase = texLoader.load("/assets/textures/Maze/hedgeFixedProbably.png");
      const texHedgeX = texLoader.load("/assets/textures/Maze/hedgeX.png");

      scene.background = new THREE.CubeTextureLoader()
        .setPath("/assets/textures/forestv4/")
        .load(["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"]);
      scene.fog = new THREE.FogExp2(0xcccccc, 0.005);

      // --- ALGORYTM GENEROWANIA (Recursive Backtracker) ---
      function generateMaze(width, height) {
          const map = [];
          // 1. Wypełnij ścianami
          for (let x = 0; x < width; x++) {
              map[x] = [];
              for (let y = 0; y < height; y++) {
                  map[x][y] = 1; 
              }
          }

          // 2. Wytnij korytarze
          function carve(x, y) {
              const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]].sort(() => Math.random() - 0.5);
              for (let i = 0; i < directions.length; i++) {
                  const dx = directions[i][0];
                  const dy = directions[i][1];
                  const nx = x + (dx * 2);
                  const ny = y + (dy * 2);

                  if (nx > 0 && nx < width && ny > 0 && ny < height && map[nx][ny] === 1) {
                      map[x + dx][y + dy] = 0;
                      map[nx][ny] = 0;
                      carve(nx, ny);
                  }
              }
          }

          map[1][1] = 0; // Start
          carve(1, 1);
          map[1][0] = 0; // Wejście
          map[width - 2][height - 1] = 0; // Wyjście
          return map;
      }

      const mazeMap = generateMaze(MAZE_WIDTH, MAZE_HEIGHT);

      // --- BUDOWANIE ŚWIATA ---
      
      // Podłoga
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(MAZE_WIDTH * WALL_SIZE, MAZE_HEIGHT * WALL_SIZE),
        new THREE.MeshStandardMaterial({ map: texGround, side: THREE.DoubleSide })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0.1;
      ground.receiveShadow = true;
      scene.add(ground);

      // Ściany (InstancedMesh dla wydajności)
      const geometry = new THREE.BoxGeometry(WALL_SIZE, WALL_SIZE, WALL_SIZE);
      const matSide = new THREE.MeshStandardMaterial({ map: texHedgeBase });
      const matTop = new THREE.MeshStandardMaterial({ map: texHedgeX });
      const materials = [matSide, matSide, matTop, matTop, matSide, matSide];

      const collisionBoxes = [];
      const wallMeshes = []; // Dla raycastera kamery

      // Policz ściany
      let wallCount = 0;
      for (let x = 0; x < MAZE_WIDTH; x++) {
          for (let y = 0; y < MAZE_HEIGHT; y++) {
              if (mazeMap[x][y] === 1) wallCount++;
          }
      }

      const mesh = new THREE.InstancedMesh(geometry, materials, wallCount);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      const dummy = new THREE.Object3D();
      let index = 0;

      for (let x = 0; x < MAZE_WIDTH; x++) {
          for (let z = 0; z < MAZE_HEIGHT; z++) {
              if (mazeMap[x][z] === 1) {
                  // Pozycja w świecie = (Grid * Rozmiar) - Offset
                  const worldX = (x * WALL_SIZE) - OFFSET_X + (WALL_SIZE/2);
                  const worldZ = (z * WALL_SIZE) - OFFSET_Z + (WALL_SIZE/2);

                  dummy.position.set(worldX, WALL_SIZE / 2, worldZ);
                  dummy.updateMatrix();
                  mesh.setMatrixAt(index++, dummy.matrix);

                  // Box kolizji
                  const box = new THREE.Box3();
                  box.setFromCenterAndSize(dummy.position, new THREE.Vector3(WALL_SIZE, WALL_SIZE, WALL_SIZE));
                  collisionBoxes.push(box);
              }
          }
      }
      scene.add(mesh);
      wallMeshes.push(mesh);

      // --- GRACZ ---
      const playerGeo = new THREE.BoxGeometry(24, 70, 24);
      playerGeo.computeBoundingBox();
      playerGeo.userData.obb = new OBB().fromBox3(playerGeo.boundingBox);
      const player = new THREE.Mesh(playerGeo, new THREE.MeshStandardMaterial({ color: "red" }));
      
      // !!! NAPRAWA SPAWNU !!!
      // Ustawiamy gracza na polu [1][1] (zawsze puste w tym algorytmie)
      const startGridX = 1;
      const startGridZ = 1;
      player.position.set(
          (startGridX * WALL_SIZE) - OFFSET_X + (WALL_SIZE/2),
          35.001, 
          (startGridZ * WALL_SIZE) - OFFSET_Z + (WALL_SIZE/2)
      );

      player.userData.obb = new OBB();
      scene.add(player);

      // Światła
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const spotLight = new THREE.SpotLight(0xffffff, 1000, 500, Math.PI / 8, 0.5); // Zwiększona moc dla Three r160
      spotLight.castShadow = true;
      scene.add(spotLight);
      scene.add(spotLight.target);

      // --- LOGIKA ---
      const keys = {};
      const speed = 5.0; 
      const rotSpeed = 0.05;
      const prevPos = new THREE.Vector3();

      window.addEventListener("keydown", (e) => (keys[e.code] = true));
      window.addEventListener("keyup", (e) => (keys[e.code] = false));

      function updatePlayer() {
        prevPos.copy(player.position);

        if (keys["ArrowUp"]) player.translateZ(-speed);
        if (keys["ArrowDown"]) player.translateZ(speed);
        if (keys["ArrowLeft"]) player.rotation.y += rotSpeed;
        if (keys["ArrowRight"]) player.rotation.y -= rotSpeed;

        player.updateMatrixWorld();
        player.userData.obb.copy(playerGeo.userData.obb);
        player.userData.obb.applyMatrix4(player.matrixWorld);

        // Prosta optymalizacja kolizji: sprawdzamy tylko pobliskie ściany?
        // Na razie sprawdzamy wszystkie (dla małego labiryntu OK)
        for (const wallBox of collisionBoxes) {
            // Szybkie sprawdzenie odległości, żeby nie liczyć OBB dla odległych ścian
            if (wallBox.getCenter(new THREE.Vector3()).distanceTo(player.position) > WALL_SIZE * 1.5) continue;

            if (player.userData.obb.intersectsBox3(wallBox)) {
                player.position.copy(prevPos);
                break; 
            }
        }

        // Kamera
        const idealOffset = new THREE.Vector3(0, 45, 75);
        idealOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
        const idealPosition = new THREE.Vector3().copy(player.position).add(idealOffset);

        const playerHeadPos = new THREE.Vector3().copy(player.position).add(new THREE.Vector3(0, 30, 0));
        const direction = new THREE.Vector3().subVectors(idealPosition, playerHeadPos).normalize();
        const dist = playerHeadPos.distanceTo(idealPosition);

        cameraRaycaster.set(playerHeadPos, direction);
        cameraRaycaster.far = dist;
        const intersects = cameraRaycaster.intersectObjects(wallMeshes);

        if (intersects.length > 0) {
           camera.position.copy(intersects[0].point).add(direction.multiplyScalar(-2));
        } else {
           camera.position.copy(idealPosition);
        }
        camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 20, 0)));

        // Światło
        spotLight.position.copy(player.position);
        spotLight.position.y += 20; 
        spotLight.target.position.copy(player.position).add(new THREE.Vector3(0, -10, -50).applyQuaternion(player.quaternion));
        spotLight.target.updateMatrixWorld();
      }

      function animate() {
        requestAnimationFrame(animate);
        updatePlayer();
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </head>
  <body></body>
</html>